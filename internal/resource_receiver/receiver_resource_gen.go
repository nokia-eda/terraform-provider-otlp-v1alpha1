// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_receiver

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ReceiverResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^otlp\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("otlp.eda.nokia.com/v1alpha1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Receiver$"), ""),
				},
				Default: stringdefault.StaticString("Receiver"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Receiver",
				MarkdownDescription: "name of the Receiver",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authorization": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"credentials": schema.StringAttribute{
								Optional:            true,
								Description:         "Credentials such as a token value",
								MarkdownDescription: "Credentials such as a token value",
							},
							"type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Authorization type",
								MarkdownDescription: "Authorization type",
								Default:             stringdefault.StaticString("Bearer"),
							},
						},
						CustomType: AuthorizationType{
							ObjectType: types.ObjectType{
								AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Authorization token for accessing the server.",
						MarkdownDescription: "Authorization token for accessing the server.",
					},
					"endpoint": schema.StringAttribute{
						Required:            true,
						Description:         "Receiver endpoint.",
						MarkdownDescription: "Receiver endpoint.",
					},
					"protocol": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Export client protocol. Once of `http` or `grpc`.",
						MarkdownDescription: "Export client protocol. Once of `http` or `grpc`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"http",
								"grpc",
							),
						},
						Default: stringdefault.StaticString("http"),
					},
					"tls": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"from_files": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"ca_file": schema.StringAttribute{
										Optional:            true,
										Description:         "Path to a certificate authority file.",
										MarkdownDescription: "Path to a certificate authority file.",
									},
									"cert_file": schema.StringAttribute{
										Optional:            true,
										Description:         "The client certificate file location.",
										MarkdownDescription: "The client certificate file location.",
									},
									"key_file": schema.StringAttribute{
										Optional:            true,
										Description:         "The client private key location.",
										MarkdownDescription: "The client private key location.",
									},
									"skip_verify": schema.BoolAttribute{
										Optional:            true,
										Description:         "If true the client will not verify the server's certificate.",
										MarkdownDescription: "If true the client will not verify the server's certificate.",
									},
								},
								CustomType: FromFilesType{
									ObjectType: types.ObjectType{
										AttrTypes: FromFilesValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Certificates files.",
								MarkdownDescription: "Certificates files.",
							},
							"from_secret": schema.StringAttribute{
								Optional:            true,
								Description:         "Secret containing a `tls.crt`, a `tls.key` and a `ca.crt` keys.\nBoth `tls.crt` and `tls.key` must be present.\nIf `ca.crt` is not present and `.trustBundle` is not set\nthe remote server certificate is not verified.",
								MarkdownDescription: "Secret containing a `tls.crt`, a `tls.key` and a `ca.crt` keys.\nBoth `tls.crt` and `tls.key` must be present.\nIf `ca.crt` is not present and `.trustBundle` is not set\nthe remote server certificate is not verified.",
							},
							"trust_bundle": schema.StringAttribute{
								Optional:            true,
								Description:         "ConfigMap containing a set of trust bundles (key `trust-bundle.pem`) used to\nverify the remote server certificates.",
								MarkdownDescription: "ConfigMap containing a set of trust bundles (key `trust-bundle.pem`) used to\nverify the remote server certificates.",
							},
						},
						CustomType: TlsType{
							ObjectType: types.ObjectType{
								AttrTypes: TlsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "TLS configuration for secure connection to the remote server.",
						MarkdownDescription: "TLS configuration for secure connection to the remote server.",
					},
					"write_options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"buffer_size": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The buffer size threshold that initiates sending the accumulated metrics to the receiver.",
								MarkdownDescription: "The buffer size threshold that initiates sending the accumulated metrics to the receiver.",
								Default:             int64default.StaticInt64(1000),
							},
							"compression": schema.StringAttribute{
								Optional:            true,
								Description:         "Compression algorithm. Only gzip supported.",
								MarkdownDescription: "Compression algorithm. Only gzip supported.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gzip",
									),
								},
							},
							"flush_interval": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Interval at which metrics stored in the local buffer are sent to the receiver.\nMetrics are sent regardless of the buffer size threshold.",
								MarkdownDescription: "Interval at which metrics stored in the local buffer are sent to the receiver.\nMetrics are sent regardless of the buffer size threshold.",
								Default:             stringdefault.StaticString("5s"),
							},
							"headers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional:            true,
											Description:         "Header name",
											MarkdownDescription: "Header name",
										},
										"value": schema.StringAttribute{
											Optional:            true,
											Description:         "Header value",
											MarkdownDescription: "Header value",
										},
									},
									CustomType: HeadersType{
										ObjectType: types.ObjectType{
											AttrTypes: HeadersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "Custom HTTP headers to be sent along with each remote write request.",
								MarkdownDescription: "Custom HTTP headers to be sent along with each remote write request.",
							},
							"max_metrics_per_export": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Maximum number of metrics per export request.",
								MarkdownDescription: "Maximum number of metrics per export request.",
								Default:             int64default.StaticInt64(500),
							},
							"retries": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"initial_interval": schema.StringAttribute{
										Optional: true,
									},
									"max_elapsed_time": schema.StringAttribute{
										Optional: true,
									},
									"max_interval": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: RetriesType{
									ObjectType: types.ObjectType{
										AttrTypes: RetriesValue{}.AttributeTypes(ctx),
									},
								},
								Required:            true,
								Description:         "Retries options",
								MarkdownDescription: "Retries options",
							},
							"timeout": schema.StringAttribute{
								Required:            true,
								Description:         "Export timeout.",
								MarkdownDescription: "Export timeout.",
							},
						},
						CustomType: WriteOptionsType{
							ObjectType: types.ObjectType{
								AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Remote write options such as: Flush interval, Retries, etc.",
						MarkdownDescription: "Remote write options such as: Flush interval, Retries, etc.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "ReceiverSpec defines the desired state of Receiver",
				MarkdownDescription: "ReceiverSpec defines the desired state of Receiver",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"error": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Last encountered error for this receiver",
						MarkdownDescription: "Last encountered error for this receiver",
					},
					"last_checked": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Last checked time for connectivity status",
						MarkdownDescription: "Last checked time for connectivity status",
					},
					"reachable": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies if the receiver is reachable",
						MarkdownDescription: "Specifies if the receiver is reachable",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "ReceiverStatus defines the observed state of Receiver",
				MarkdownDescription: "ReceiverStatus defines the observed state of Receiver",
			},
		},
	}
}

type ReceiverModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return nil, diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return nil, diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return nil, diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.ObjectValue, was: %T`, tlsAttribute))
	}

	writeOptionsAttribute, ok := attributes["write_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_options is missing from object`)

		return nil, diags
	}

	writeOptionsVal, ok := writeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_options expected to be basetypes.ObjectValue, was: %T`, writeOptionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Authorization: authorizationVal,
		Endpoint:      endpointVal,
		Protocol:      protocolVal,
		Tls:           tlsVal,
		WriteOptions:  writeOptionsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.ObjectValue, was: %T`, authorizationAttribute))
	}

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.ObjectValue, was: %T`, tlsAttribute))
	}

	writeOptionsAttribute, ok := attributes["write_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_options is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	writeOptionsVal, ok := writeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_options expected to be basetypes.ObjectValue, was: %T`, writeOptionsAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Authorization: authorizationVal,
		Endpoint:      endpointVal,
		Protocol:      protocolVal,
		Tls:           tlsVal,
		WriteOptions:  writeOptionsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Authorization basetypes.ObjectValue `tfsdk:"authorization"`
	Endpoint      basetypes.StringValue `tfsdk:"endpoint"`
	Protocol      basetypes.StringValue `tfsdk:"protocol"`
	Tls           basetypes.ObjectValue `tfsdk:"tls"`
	WriteOptions  basetypes.ObjectValue `tfsdk:"write_options"`
	state         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["authorization"] = basetypes.ObjectType{
		AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tls"] = basetypes.ObjectType{
		AttrTypes: TlsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["write_options"] = basetypes.ObjectType{
		AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Authorization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authorization"] = val

		val, err = v.Endpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Tls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tls"] = val

		val, err = v.WriteOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["write_options"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authorization basetypes.ObjectValue

	if v.Authorization.IsNull() {
		authorization = types.ObjectNull(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Authorization.IsUnknown() {
		authorization = types.ObjectUnknown(
			AuthorizationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Authorization.IsNull() && !v.Authorization.IsUnknown() {
		authorization = types.ObjectValueMust(
			AuthorizationValue{}.AttributeTypes(ctx),
			v.Authorization.Attributes(),
		)
	}

	var tls basetypes.ObjectValue

	if v.Tls.IsNull() {
		tls = types.ObjectNull(
			TlsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tls.IsUnknown() {
		tls = types.ObjectUnknown(
			TlsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tls.IsNull() && !v.Tls.IsUnknown() {
		tls = types.ObjectValueMust(
			TlsValue{}.AttributeTypes(ctx),
			v.Tls.Attributes(),
		)
	}

	var writeOptions basetypes.ObjectValue

	if v.WriteOptions.IsNull() {
		writeOptions = types.ObjectNull(
			WriteOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.WriteOptions.IsUnknown() {
		writeOptions = types.ObjectUnknown(
			WriteOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WriteOptions.IsNull() && !v.WriteOptions.IsUnknown() {
		writeOptions = types.ObjectValueMust(
			WriteOptionsValue{}.AttributeTypes(ctx),
			v.WriteOptions.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
		"endpoint": basetypes.StringType{},
		"protocol": basetypes.StringType{},
		"tls": basetypes.ObjectType{
			AttrTypes: TlsValue{}.AttributeTypes(ctx),
		},
		"write_options": basetypes.ObjectType{
			AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authorization": authorization,
			"endpoint":      v.Endpoint,
			"protocol":      v.Protocol,
			"tls":           tls,
			"write_options": writeOptions,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authorization.Equal(other.Authorization) {
		return false
	}

	if !v.Endpoint.Equal(other.Endpoint) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Tls.Equal(other.Tls) {
		return false
	}

	if !v.WriteOptions.Equal(other.WriteOptions) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authorization": basetypes.ObjectType{
			AttrTypes: AuthorizationValue{}.AttributeTypes(ctx),
		},
		"endpoint": basetypes.StringType{},
		"protocol": basetypes.StringType{},
		"tls": basetypes.ObjectType{
			AttrTypes: TlsValue{}.AttributeTypes(ctx),
		},
		"write_options": basetypes.ObjectType{
			AttrTypes: WriteOptionsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AuthorizationType{}

type AuthorizationType struct {
	basetypes.ObjectType
}

func (t AuthorizationType) Equal(o attr.Type) bool {
	other, ok := o.(AuthorizationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthorizationType) String() string {
	return "AuthorizationType"
}

func (t AuthorizationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	credentialsAttribute, ok := attributes["credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credentials is missing from object`)

		return nil, diags
	}

	credentialsVal, ok := credentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credentials expected to be basetypes.StringValue, was: %T`, credentialsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthorizationValue{
		Credentials:       credentialsVal,
		AuthorizationType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueNull() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthorizationValueUnknown() AuthorizationValue {
	return AuthorizationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthorizationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthorizationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, a missing attribute value was detected. "+
					"A AuthorizationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthorizationValue Attribute Type",
				"While creating a AuthorizationValue value, an invalid attribute value was detected. "+
					"A AuthorizationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthorizationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthorizationValue Attribute Value",
				"While creating a AuthorizationValue value, an extra attribute value was detected. "+
					"A AuthorizationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthorizationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	credentialsAttribute, ok := attributes["credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credentials is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	credentialsVal, ok := credentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credentials expected to be basetypes.StringValue, was: %T`, credentialsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthorizationValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAuthorizationValueUnknown(), diags
	}

	return AuthorizationValue{
		Credentials:       credentialsVal,
		AuthorizationType: typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthorizationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthorizationValue {
	object, diags := NewAuthorizationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthorizationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthorizationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthorizationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthorizationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthorizationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthorizationValueMust(AuthorizationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthorizationType) ValueType(ctx context.Context) attr.Value {
	return AuthorizationValue{}
}

var _ basetypes.ObjectValuable = AuthorizationValue{}

type AuthorizationValue struct {
	Credentials       basetypes.StringValue `tfsdk:"credentials"`
	AuthorizationType basetypes.StringValue `tfsdk:"type"`
	state             attr.ValueState
}

func (v AuthorizationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["credentials"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Credentials.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credentials"] = val

		val, err = v.AuthorizationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthorizationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthorizationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthorizationValue) String() string {
	return "AuthorizationValue"
}

func (v AuthorizationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"credentials": basetypes.StringType{},
		"type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"credentials": v.Credentials,
			"type":        v.AuthorizationType,
		})

	return objVal, diags
}

func (v AuthorizationValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthorizationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Credentials.Equal(other.Credentials) {
		return false
	}

	if !v.AuthorizationType.Equal(other.AuthorizationType) {
		return false
	}

	return true
}

func (v AuthorizationValue) Type(ctx context.Context) attr.Type {
	return AuthorizationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthorizationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"credentials": basetypes.StringType{},
		"type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TlsType{}

type TlsType struct {
	basetypes.ObjectType
}

func (t TlsType) Equal(o attr.Type) bool {
	other, ok := o.(TlsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TlsType) String() string {
	return "TlsType"
}

func (t TlsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fromFilesAttribute, ok := attributes["from_files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_files is missing from object`)

		return nil, diags
	}

	fromFilesVal, ok := fromFilesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_files expected to be basetypes.ObjectValue, was: %T`, fromFilesAttribute))
	}

	fromSecretAttribute, ok := attributes["from_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_secret is missing from object`)

		return nil, diags
	}

	fromSecretVal, ok := fromSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_secret expected to be basetypes.StringValue, was: %T`, fromSecretAttribute))
	}

	trustBundleAttribute, ok := attributes["trust_bundle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trust_bundle is missing from object`)

		return nil, diags
	}

	trustBundleVal, ok := trustBundleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trust_bundle expected to be basetypes.StringValue, was: %T`, trustBundleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TlsValue{
		FromFiles:   fromFilesVal,
		FromSecret:  fromSecretVal,
		TrustBundle: trustBundleVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTlsValueNull() TlsValue {
	return TlsValue{
		state: attr.ValueStateNull,
	}
}

func NewTlsValueUnknown() TlsValue {
	return TlsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTlsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TlsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TlsValue Attribute Value",
				"While creating a TlsValue value, a missing attribute value was detected. "+
					"A TlsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TlsValue Attribute Type",
				"While creating a TlsValue value, an invalid attribute value was detected. "+
					"A TlsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TlsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TlsValue Attribute Value",
				"While creating a TlsValue value, an extra attribute value was detected. "+
					"A TlsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TlsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTlsValueUnknown(), diags
	}

	fromFilesAttribute, ok := attributes["from_files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_files is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	fromFilesVal, ok := fromFilesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_files expected to be basetypes.ObjectValue, was: %T`, fromFilesAttribute))
	}

	fromSecretAttribute, ok := attributes["from_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_secret is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	fromSecretVal, ok := fromSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_secret expected to be basetypes.StringValue, was: %T`, fromSecretAttribute))
	}

	trustBundleAttribute, ok := attributes["trust_bundle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trust_bundle is missing from object`)

		return NewTlsValueUnknown(), diags
	}

	trustBundleVal, ok := trustBundleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trust_bundle expected to be basetypes.StringValue, was: %T`, trustBundleAttribute))
	}

	if diags.HasError() {
		return NewTlsValueUnknown(), diags
	}

	return TlsValue{
		FromFiles:   fromFilesVal,
		FromSecret:  fromSecretVal,
		TrustBundle: trustBundleVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTlsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TlsValue {
	object, diags := NewTlsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTlsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TlsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTlsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTlsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTlsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTlsValueMust(TlsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TlsType) ValueType(ctx context.Context) attr.Value {
	return TlsValue{}
}

var _ basetypes.ObjectValuable = TlsValue{}

type TlsValue struct {
	FromFiles   basetypes.ObjectValue `tfsdk:"from_files"`
	FromSecret  basetypes.StringValue `tfsdk:"from_secret"`
	TrustBundle basetypes.StringValue `tfsdk:"trust_bundle"`
	state       attr.ValueState
}

func (v TlsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["from_files"] = basetypes.ObjectType{
		AttrTypes: FromFilesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["from_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["trust_bundle"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.FromFiles.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_files"] = val

		val, err = v.FromSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_secret"] = val

		val, err = v.TrustBundle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trust_bundle"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TlsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TlsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TlsValue) String() string {
	return "TlsValue"
}

func (v TlsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var fromFiles basetypes.ObjectValue

	if v.FromFiles.IsNull() {
		fromFiles = types.ObjectNull(
			FromFilesValue{}.AttributeTypes(ctx),
		)
	}

	if v.FromFiles.IsUnknown() {
		fromFiles = types.ObjectUnknown(
			FromFilesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.FromFiles.IsNull() && !v.FromFiles.IsUnknown() {
		fromFiles = types.ObjectValueMust(
			FromFilesValue{}.AttributeTypes(ctx),
			v.FromFiles.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"from_files": basetypes.ObjectType{
			AttrTypes: FromFilesValue{}.AttributeTypes(ctx),
		},
		"from_secret":  basetypes.StringType{},
		"trust_bundle": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"from_files":   fromFiles,
			"from_secret":  v.FromSecret,
			"trust_bundle": v.TrustBundle,
		})

	return objVal, diags
}

func (v TlsValue) Equal(o attr.Value) bool {
	other, ok := o.(TlsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FromFiles.Equal(other.FromFiles) {
		return false
	}

	if !v.FromSecret.Equal(other.FromSecret) {
		return false
	}

	if !v.TrustBundle.Equal(other.TrustBundle) {
		return false
	}

	return true
}

func (v TlsValue) Type(ctx context.Context) attr.Type {
	return TlsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TlsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"from_files": basetypes.ObjectType{
			AttrTypes: FromFilesValue{}.AttributeTypes(ctx),
		},
		"from_secret":  basetypes.StringType{},
		"trust_bundle": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FromFilesType{}

type FromFilesType struct {
	basetypes.ObjectType
}

func (t FromFilesType) Equal(o attr.Type) bool {
	other, ok := o.(FromFilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FromFilesType) String() string {
	return "FromFilesType"
}

func (t FromFilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	caFileAttribute, ok := attributes["ca_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_file is missing from object`)

		return nil, diags
	}

	caFileVal, ok := caFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_file expected to be basetypes.StringValue, was: %T`, caFileAttribute))
	}

	certFileAttribute, ok := attributes["cert_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_file is missing from object`)

		return nil, diags
	}

	certFileVal, ok := certFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_file expected to be basetypes.StringValue, was: %T`, certFileAttribute))
	}

	keyFileAttribute, ok := attributes["key_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_file is missing from object`)

		return nil, diags
	}

	keyFileVal, ok := keyFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_file expected to be basetypes.StringValue, was: %T`, keyFileAttribute))
	}

	skipVerifyAttribute, ok := attributes["skip_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verify is missing from object`)

		return nil, diags
	}

	skipVerifyVal, ok := skipVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verify expected to be basetypes.BoolValue, was: %T`, skipVerifyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FromFilesValue{
		CaFile:     caFileVal,
		CertFile:   certFileVal,
		KeyFile:    keyFileVal,
		SkipVerify: skipVerifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewFromFilesValueNull() FromFilesValue {
	return FromFilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFromFilesValueUnknown() FromFilesValue {
	return FromFilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFromFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FromFilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FromFilesValue Attribute Value",
				"While creating a FromFilesValue value, a missing attribute value was detected. "+
					"A FromFilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FromFilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FromFilesValue Attribute Type",
				"While creating a FromFilesValue value, an invalid attribute value was detected. "+
					"A FromFilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FromFilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FromFilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FromFilesValue Attribute Value",
				"While creating a FromFilesValue value, an extra attribute value was detected. "+
					"A FromFilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FromFilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFromFilesValueUnknown(), diags
	}

	caFileAttribute, ok := attributes["ca_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ca_file is missing from object`)

		return NewFromFilesValueUnknown(), diags
	}

	caFileVal, ok := caFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ca_file expected to be basetypes.StringValue, was: %T`, caFileAttribute))
	}

	certFileAttribute, ok := attributes["cert_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_file is missing from object`)

		return NewFromFilesValueUnknown(), diags
	}

	certFileVal, ok := certFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_file expected to be basetypes.StringValue, was: %T`, certFileAttribute))
	}

	keyFileAttribute, ok := attributes["key_file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_file is missing from object`)

		return NewFromFilesValueUnknown(), diags
	}

	keyFileVal, ok := keyFileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_file expected to be basetypes.StringValue, was: %T`, keyFileAttribute))
	}

	skipVerifyAttribute, ok := attributes["skip_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_verify is missing from object`)

		return NewFromFilesValueUnknown(), diags
	}

	skipVerifyVal, ok := skipVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_verify expected to be basetypes.BoolValue, was: %T`, skipVerifyAttribute))
	}

	if diags.HasError() {
		return NewFromFilesValueUnknown(), diags
	}

	return FromFilesValue{
		CaFile:     caFileVal,
		CertFile:   certFileVal,
		KeyFile:    keyFileVal,
		SkipVerify: skipVerifyVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewFromFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FromFilesValue {
	object, diags := NewFromFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFromFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FromFilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFromFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFromFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFromFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFromFilesValueMust(FromFilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FromFilesType) ValueType(ctx context.Context) attr.Value {
	return FromFilesValue{}
}

var _ basetypes.ObjectValuable = FromFilesValue{}

type FromFilesValue struct {
	CaFile     basetypes.StringValue `tfsdk:"ca_file"`
	CertFile   basetypes.StringValue `tfsdk:"cert_file"`
	KeyFile    basetypes.StringValue `tfsdk:"key_file"`
	SkipVerify basetypes.BoolValue   `tfsdk:"skip_verify"`
	state      attr.ValueState
}

func (v FromFilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ca_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cert_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key_file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["skip_verify"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CaFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ca_file"] = val

		val, err = v.CertFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_file"] = val

		val, err = v.KeyFile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_file"] = val

		val, err = v.SkipVerify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_verify"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FromFilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FromFilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FromFilesValue) String() string {
	return "FromFilesValue"
}

func (v FromFilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ca_file":     basetypes.StringType{},
		"cert_file":   basetypes.StringType{},
		"key_file":    basetypes.StringType{},
		"skip_verify": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ca_file":     v.CaFile,
			"cert_file":   v.CertFile,
			"key_file":    v.KeyFile,
			"skip_verify": v.SkipVerify,
		})

	return objVal, diags
}

func (v FromFilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FromFilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CaFile.Equal(other.CaFile) {
		return false
	}

	if !v.CertFile.Equal(other.CertFile) {
		return false
	}

	if !v.KeyFile.Equal(other.KeyFile) {
		return false
	}

	if !v.SkipVerify.Equal(other.SkipVerify) {
		return false
	}

	return true
}

func (v FromFilesValue) Type(ctx context.Context) attr.Type {
	return FromFilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FromFilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ca_file":     basetypes.StringType{},
		"cert_file":   basetypes.StringType{},
		"key_file":    basetypes.StringType{},
		"skip_verify": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = WriteOptionsType{}

type WriteOptionsType struct {
	basetypes.ObjectType
}

func (t WriteOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(WriteOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WriteOptionsType) String() string {
	return "WriteOptionsType"
}

func (t WriteOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bufferSizeAttribute, ok := attributes["buffer_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`buffer_size is missing from object`)

		return nil, diags
	}

	bufferSizeVal, ok := bufferSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`buffer_size expected to be basetypes.Int64Value, was: %T`, bufferSizeAttribute))
	}

	compressionAttribute, ok := attributes["compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compression is missing from object`)

		return nil, diags
	}

	compressionVal, ok := compressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compression expected to be basetypes.StringValue, was: %T`, compressionAttribute))
	}

	flushIntervalAttribute, ok := attributes["flush_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flush_interval is missing from object`)

		return nil, diags
	}

	flushIntervalVal, ok := flushIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flush_interval expected to be basetypes.StringValue, was: %T`, flushIntervalAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return nil, diags
	}

	headersVal, ok := headersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ListValue, was: %T`, headersAttribute))
	}

	maxMetricsPerExportAttribute, ok := attributes["max_metrics_per_export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_metrics_per_export is missing from object`)

		return nil, diags
	}

	maxMetricsPerExportVal, ok := maxMetricsPerExportAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_metrics_per_export expected to be basetypes.Int64Value, was: %T`, maxMetricsPerExportAttribute))
	}

	retriesAttribute, ok := attributes["retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retries is missing from object`)

		return nil, diags
	}

	retriesVal, ok := retriesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retries expected to be basetypes.ObjectValue, was: %T`, retriesAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.StringValue, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WriteOptionsValue{
		BufferSize:          bufferSizeVal,
		Compression:         compressionVal,
		FlushInterval:       flushIntervalVal,
		Headers:             headersVal,
		MaxMetricsPerExport: maxMetricsPerExportVal,
		Retries:             retriesVal,
		Timeout:             timeoutVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewWriteOptionsValueNull() WriteOptionsValue {
	return WriteOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewWriteOptionsValueUnknown() WriteOptionsValue {
	return WriteOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWriteOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WriteOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WriteOptionsValue Attribute Value",
				"While creating a WriteOptionsValue value, a missing attribute value was detected. "+
					"A WriteOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WriteOptionsValue Attribute Type",
				"While creating a WriteOptionsValue value, an invalid attribute value was detected. "+
					"A WriteOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WriteOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WriteOptionsValue Attribute Value",
				"While creating a WriteOptionsValue value, an extra attribute value was detected. "+
					"A WriteOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WriteOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWriteOptionsValueUnknown(), diags
	}

	bufferSizeAttribute, ok := attributes["buffer_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`buffer_size is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	bufferSizeVal, ok := bufferSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`buffer_size expected to be basetypes.Int64Value, was: %T`, bufferSizeAttribute))
	}

	compressionAttribute, ok := attributes["compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compression is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	compressionVal, ok := compressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compression expected to be basetypes.StringValue, was: %T`, compressionAttribute))
	}

	flushIntervalAttribute, ok := attributes["flush_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flush_interval is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	flushIntervalVal, ok := flushIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flush_interval expected to be basetypes.StringValue, was: %T`, flushIntervalAttribute))
	}

	headersAttribute, ok := attributes["headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`headers is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	headersVal, ok := headersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`headers expected to be basetypes.ListValue, was: %T`, headersAttribute))
	}

	maxMetricsPerExportAttribute, ok := attributes["max_metrics_per_export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_metrics_per_export is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	maxMetricsPerExportVal, ok := maxMetricsPerExportAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_metrics_per_export expected to be basetypes.Int64Value, was: %T`, maxMetricsPerExportAttribute))
	}

	retriesAttribute, ok := attributes["retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retries is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	retriesVal, ok := retriesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retries expected to be basetypes.ObjectValue, was: %T`, retriesAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewWriteOptionsValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.StringValue, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewWriteOptionsValueUnknown(), diags
	}

	return WriteOptionsValue{
		BufferSize:          bufferSizeVal,
		Compression:         compressionVal,
		FlushInterval:       flushIntervalVal,
		Headers:             headersVal,
		MaxMetricsPerExport: maxMetricsPerExportVal,
		Retries:             retriesVal,
		Timeout:             timeoutVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewWriteOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WriteOptionsValue {
	object, diags := NewWriteOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWriteOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WriteOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWriteOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWriteOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWriteOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWriteOptionsValueMust(WriteOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WriteOptionsType) ValueType(ctx context.Context) attr.Value {
	return WriteOptionsValue{}
}

var _ basetypes.ObjectValuable = WriteOptionsValue{}

type WriteOptionsValue struct {
	BufferSize          basetypes.Int64Value  `tfsdk:"buffer_size"`
	Compression         basetypes.StringValue `tfsdk:"compression"`
	FlushInterval       basetypes.StringValue `tfsdk:"flush_interval"`
	Headers             basetypes.ListValue   `tfsdk:"headers"`
	MaxMetricsPerExport basetypes.Int64Value  `tfsdk:"max_metrics_per_export"`
	Retries             basetypes.ObjectValue `tfsdk:"retries"`
	Timeout             basetypes.StringValue `tfsdk:"timeout"`
	state               attr.ValueState
}

func (v WriteOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["buffer_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["compression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["flush_interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["headers"] = basetypes.ListType{
		ElemType: HeadersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["max_metrics_per_export"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["retries"] = basetypes.ObjectType{
		AttrTypes: RetriesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BufferSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["buffer_size"] = val

		val, err = v.Compression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["compression"] = val

		val, err = v.FlushInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flush_interval"] = val

		val, err = v.Headers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["headers"] = val

		val, err = v.MaxMetricsPerExport.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_metrics_per_export"] = val

		val, err = v.Retries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retries"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WriteOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WriteOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WriteOptionsValue) String() string {
	return "WriteOptionsValue"
}

func (v WriteOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	headers := types.ListValueMust(
		HeadersType{
			basetypes.ObjectType{
				AttrTypes: HeadersValue{}.AttributeTypes(ctx),
			},
		},
		v.Headers.Elements(),
	)

	if v.Headers.IsNull() {
		headers = types.ListNull(
			HeadersType{
				basetypes.ObjectType{
					AttrTypes: HeadersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Headers.IsUnknown() {
		headers = types.ListUnknown(
			HeadersType{
				basetypes.ObjectType{
					AttrTypes: HeadersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var retries basetypes.ObjectValue

	if v.Retries.IsNull() {
		retries = types.ObjectNull(
			RetriesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Retries.IsUnknown() {
		retries = types.ObjectUnknown(
			RetriesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Retries.IsNull() && !v.Retries.IsUnknown() {
		retries = types.ObjectValueMust(
			RetriesValue{}.AttributeTypes(ctx),
			v.Retries.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"buffer_size":    basetypes.Int64Type{},
		"compression":    basetypes.StringType{},
		"flush_interval": basetypes.StringType{},
		"headers": basetypes.ListType{
			ElemType: HeadersValue{}.Type(ctx),
		},
		"max_metrics_per_export": basetypes.Int64Type{},
		"retries": basetypes.ObjectType{
			AttrTypes: RetriesValue{}.AttributeTypes(ctx),
		},
		"timeout": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"buffer_size":            v.BufferSize,
			"compression":            v.Compression,
			"flush_interval":         v.FlushInterval,
			"headers":                headers,
			"max_metrics_per_export": v.MaxMetricsPerExport,
			"retries":                retries,
			"timeout":                v.Timeout,
		})

	return objVal, diags
}

func (v WriteOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(WriteOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BufferSize.Equal(other.BufferSize) {
		return false
	}

	if !v.Compression.Equal(other.Compression) {
		return false
	}

	if !v.FlushInterval.Equal(other.FlushInterval) {
		return false
	}

	if !v.Headers.Equal(other.Headers) {
		return false
	}

	if !v.MaxMetricsPerExport.Equal(other.MaxMetricsPerExport) {
		return false
	}

	if !v.Retries.Equal(other.Retries) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v WriteOptionsValue) Type(ctx context.Context) attr.Type {
	return WriteOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WriteOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"buffer_size":    basetypes.Int64Type{},
		"compression":    basetypes.StringType{},
		"flush_interval": basetypes.StringType{},
		"headers": basetypes.ListType{
			ElemType: HeadersValue{}.Type(ctx),
		},
		"max_metrics_per_export": basetypes.Int64Type{},
		"retries": basetypes.ObjectType{
			AttrTypes: RetriesValue{}.AttributeTypes(ctx),
		},
		"timeout": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = HeadersType{}

type HeadersType struct {
	basetypes.ObjectType
}

func (t HeadersType) Equal(o attr.Type) bool {
	other, ok := o.(HeadersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HeadersType) String() string {
	return "HeadersType"
}

func (t HeadersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HeadersValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueNull() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateNull,
	}
}

func NewHeadersValueUnknown() HeadersValue {
	return HeadersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHeadersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HeadersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HeadersValue Attribute Value",
				"While creating a HeadersValue value, a missing attribute value was detected. "+
					"A HeadersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HeadersValue Attribute Type",
				"While creating a HeadersValue value, an invalid attribute value was detected. "+
					"A HeadersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HeadersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HeadersValue Attribute Value",
				"While creating a HeadersValue value, an extra attribute value was detected. "+
					"A HeadersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HeadersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewHeadersValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewHeadersValueUnknown(), diags
	}

	return HeadersValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHeadersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HeadersValue {
	object, diags := NewHeadersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHeadersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HeadersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHeadersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHeadersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHeadersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHeadersValueMust(HeadersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HeadersType) ValueType(ctx context.Context) attr.Value {
	return HeadersValue{}
}

var _ basetypes.ObjectValuable = HeadersValue{}

type HeadersValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v HeadersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HeadersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HeadersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HeadersValue) String() string {
	return "HeadersValue"
}

func (v HeadersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v HeadersValue) Equal(o attr.Value) bool {
	other, ok := o.(HeadersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v HeadersValue) Type(ctx context.Context) attr.Type {
	return HeadersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HeadersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RetriesType{}

type RetriesType struct {
	basetypes.ObjectType
}

func (t RetriesType) Equal(o attr.Type) bool {
	other, ok := o.(RetriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RetriesType) String() string {
	return "RetriesType"
}

func (t RetriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	initialIntervalAttribute, ok := attributes["initial_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_interval is missing from object`)

		return nil, diags
	}

	initialIntervalVal, ok := initialIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_interval expected to be basetypes.StringValue, was: %T`, initialIntervalAttribute))
	}

	maxElapsedTimeAttribute, ok := attributes["max_elapsed_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_elapsed_time is missing from object`)

		return nil, diags
	}

	maxElapsedTimeVal, ok := maxElapsedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_elapsed_time expected to be basetypes.StringValue, was: %T`, maxElapsedTimeAttribute))
	}

	maxIntervalAttribute, ok := attributes["max_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_interval is missing from object`)

		return nil, diags
	}

	maxIntervalVal, ok := maxIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_interval expected to be basetypes.StringValue, was: %T`, maxIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RetriesValue{
		InitialInterval: initialIntervalVal,
		MaxElapsedTime:  maxElapsedTimeVal,
		MaxInterval:     maxIntervalVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRetriesValueNull() RetriesValue {
	return RetriesValue{
		state: attr.ValueStateNull,
	}
}

func NewRetriesValueUnknown() RetriesValue {
	return RetriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRetriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RetriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RetriesValue Attribute Value",
				"While creating a RetriesValue value, a missing attribute value was detected. "+
					"A RetriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RetriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RetriesValue Attribute Type",
				"While creating a RetriesValue value, an invalid attribute value was detected. "+
					"A RetriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RetriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RetriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RetriesValue Attribute Value",
				"While creating a RetriesValue value, an extra attribute value was detected. "+
					"A RetriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RetriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRetriesValueUnknown(), diags
	}

	initialIntervalAttribute, ok := attributes["initial_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_interval is missing from object`)

		return NewRetriesValueUnknown(), diags
	}

	initialIntervalVal, ok := initialIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_interval expected to be basetypes.StringValue, was: %T`, initialIntervalAttribute))
	}

	maxElapsedTimeAttribute, ok := attributes["max_elapsed_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_elapsed_time is missing from object`)

		return NewRetriesValueUnknown(), diags
	}

	maxElapsedTimeVal, ok := maxElapsedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_elapsed_time expected to be basetypes.StringValue, was: %T`, maxElapsedTimeAttribute))
	}

	maxIntervalAttribute, ok := attributes["max_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_interval is missing from object`)

		return NewRetriesValueUnknown(), diags
	}

	maxIntervalVal, ok := maxIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_interval expected to be basetypes.StringValue, was: %T`, maxIntervalAttribute))
	}

	if diags.HasError() {
		return NewRetriesValueUnknown(), diags
	}

	return RetriesValue{
		InitialInterval: initialIntervalVal,
		MaxElapsedTime:  maxElapsedTimeVal,
		MaxInterval:     maxIntervalVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRetriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RetriesValue {
	object, diags := NewRetriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRetriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RetriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRetriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRetriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRetriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRetriesValueMust(RetriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RetriesType) ValueType(ctx context.Context) attr.Value {
	return RetriesValue{}
}

var _ basetypes.ObjectValuable = RetriesValue{}

type RetriesValue struct {
	InitialInterval basetypes.StringValue `tfsdk:"initial_interval"`
	MaxElapsedTime  basetypes.StringValue `tfsdk:"max_elapsed_time"`
	MaxInterval     basetypes.StringValue `tfsdk:"max_interval"`
	state           attr.ValueState
}

func (v RetriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["initial_interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_elapsed_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_interval"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InitialInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_interval"] = val

		val, err = v.MaxElapsedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_elapsed_time"] = val

		val, err = v.MaxInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RetriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RetriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RetriesValue) String() string {
	return "RetriesValue"
}

func (v RetriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"initial_interval": basetypes.StringType{},
		"max_elapsed_time": basetypes.StringType{},
		"max_interval":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"initial_interval": v.InitialInterval,
			"max_elapsed_time": v.MaxElapsedTime,
			"max_interval":     v.MaxInterval,
		})

	return objVal, diags
}

func (v RetriesValue) Equal(o attr.Value) bool {
	other, ok := o.(RetriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InitialInterval.Equal(other.InitialInterval) {
		return false
	}

	if !v.MaxElapsedTime.Equal(other.MaxElapsedTime) {
		return false
	}

	if !v.MaxInterval.Equal(other.MaxInterval) {
		return false
	}

	return true
}

func (v RetriesValue) Type(ctx context.Context) attr.Type {
	return RetriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RetriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"initial_interval": basetypes.StringType{},
		"max_elapsed_time": basetypes.StringType{},
		"max_interval":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return nil, diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	lastCheckedAttribute, ok := attributes["last_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_checked is missing from object`)

		return nil, diags
	}

	lastCheckedVal, ok := lastCheckedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_checked expected to be basetypes.StringValue, was: %T`, lastCheckedAttribute))
	}

	reachableAttribute, ok := attributes["reachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable is missing from object`)

		return nil, diags
	}

	reachableVal, ok := reachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable expected to be basetypes.BoolValue, was: %T`, reachableAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Error:       errorVal,
		LastChecked: lastCheckedVal,
		Reachable:   reachableVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	lastCheckedAttribute, ok := attributes["last_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_checked is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastCheckedVal, ok := lastCheckedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_checked expected to be basetypes.StringValue, was: %T`, lastCheckedAttribute))
	}

	reachableAttribute, ok := attributes["reachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	reachableVal, ok := reachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable expected to be basetypes.BoolValue, was: %T`, reachableAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Error:       errorVal,
		LastChecked: lastCheckedVal,
		Reachable:   reachableVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Error       basetypes.StringValue `tfsdk:"error"`
	LastChecked basetypes.StringValue `tfsdk:"last_checked"`
	Reachable   basetypes.BoolValue   `tfsdk:"reachable"`
	state       attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_checked"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reachable"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Error.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error"] = val

		val, err = v.LastChecked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_checked"] = val

		val, err = v.Reachable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"error":        basetypes.StringType{},
		"last_checked": basetypes.StringType{},
		"reachable":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"error":        v.Error,
			"last_checked": v.LastChecked,
			"reachable":    v.Reachable,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Error.Equal(other.Error) {
		return false
	}

	if !v.LastChecked.Equal(other.LastChecked) {
		return false
	}

	if !v.Reachable.Equal(other.Reachable) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"error":        basetypes.StringType{},
		"last_checked": basetypes.StringType{},
		"reachable":    basetypes.BoolType{},
	}
}
